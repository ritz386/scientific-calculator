<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nonlinear Regression Analysis</title>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            padding: 5px;
        }
        
        .container {
            max-width: 1050px;
            margin: 0;
            background: black;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 3px;
        }
        
        h1 {
            color: #FFFFFF;
            margin-bottom: 7px;
            text-align: left;
            font-size: 25px;
        }
        
        /* Download buttons container */
        .download-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 7px;
        }
        
        .download-btn {
            background: #000;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
            border: 1px solid #FFFFFF;
        }
        
        .download-btn:hover {
            background: #333;
        }
        
        /* Desktop Layout - All in one row */
        .main-grid {
            display: grid;
            grid-template-columns: 20% 30% 48.8%;
            gap: 6px;
            margin-bottom: 7px;
            align-items: stretch;
            height: 500px; /* FIXED: Set fixed height for the grid */
        }
        
        /* Mobile Layout - First two in row 1, graph in row 2 */
        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                gap: 5px;
                height: auto; /* Allow auto height on mobile */
            }
            
            .container {
                padding: 5px;
            }
            
            body {
                padding: 2px;
            }
            
            h1 {
                font-size: 18px;
                margin-bottom: 5px;
            }
            
            .download-buttons {
                flex-direction: column;
                gap: 5px;
            }
            
            .download-btn {
                width: 100%;
                padding: 5px 10px;
            }
        }
        
        .section {
            background: #f9f9f9;
            padding: 6px;
            border-radius: 3px;
            border: 1px solid #e0e0e0;
            height: 100%; /* Keep 100% of parent grid height */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* FIXED: Prevent content from expanding container */
        }
        
        .section h2 {
            color: #333;
            font-size: 16px;
            margin-bottom: 5px;
            border-bottom: 2px solid #000;
            padding-bottom: 2px;
            flex-shrink: 0; /* FIXED: Prevent header from shrinking */
        }
        
        .data-input-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
            min-height: 0; /* FIXED: Allow container to shrink properly */
            overflow: hidden; /* FIXED: Prevent overflow issues */
        }
        
        .data-header {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3px;
            font-weight: bold;
            color: #333;
            padding: 0 3px;
            font-size: 16px;
            flex-shrink: 0; /* FIXED: Keep header fixed */
        }
        
        .data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3px;
            flex: 1;
            min-height: 200px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 2px;
            background: white;
        }
        
        .data-column {
            display: flex;
            flex-direction: column;
            min-height: 0; /* FIXED: Allow proper flex behavior */
        }
        
        .data-cell {
            padding: 2px 3px;
            border-bottom: 1px solid #f0f0f0;
            border-right: 1px solid #f0f0f0;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            min-height: 20px;
            outline: none;
            background: white;
            flex-shrink: 0; /* FIXED: Prevent cells from shrinking */
        }
        
        .data-cell:focus {
            background: #f8f8f8;
            outline: 3px solid #000;
            z-index: 1;
            position: relative;
        }
        
        .data-cell.empty {
            color: #999;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            flex-shrink: 0; /* FIXED: Prevent input groups from expanding */
        }
        
        label {
            font-weight: 600;
            margin-bottom: 6px;
            color: #333;
            font-size: 16px;
        }
        
        input[type="text"] {
            padding: 3px;
            border: 1px solid #ddd;
            border-radius: 2px;
            font-size: 16px;
        }
        
        .param-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 3px;
            margin-top: 3px;
        }
        
        .param-input {
            display: flex;
            flex-direction: column;
        }
        
        .param-input label {
            font-size: 16px;
            text-align: center;
            margin-bottom: 1px;
        }
        
        .param-input input {
            padding: 2px;
            font-size: 14px;
            text-align: center;
            width: 100%;
        }
        
        button {
            background: #000;
            color: white;
            border: none;
            padding: 4px 7px;
            border-radius: 2px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 3px;
        }
        
        button:hover {
            background: #333;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .plot-container {
            width: 100%;
            height: 100%;
            min-height: 400px;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            background: white;
            flex: 1;
            min-height: 0; /* FIXED: Critical for flex container */
        }
        
        @media (max-width: 768px) {
            .plot-container {
                min-height: 350px;
            }
        }
        
        .results {
            background: ##000000;
            padding: 6px;
            border-radius: 3px;
            border: 1px solid #e0e0e0;
            margin-top: 6px;
        }
        
        .results h2 {
            color: #FFFFFF;
            margin-bottom: 5px;
            border-bottom: 2px solid #000;
            padding-bottom: 2px;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            margin-bottom: 6px;
        }
        
        @media (max-width: 1024px) {
            .results-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .results-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        .result-item {
            background: #fff;
            padding: 3px;
            border-radius: 2px;
            border: 1px solid #ddd;
        }
        
        .result-label {
            font-size: 16px;
            color: #666;
            font-weight: 600;
        }
        
        .result-value {
            font-size: 16px;
            color: #000;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        .stats-row {
            display: flex;
            gap: 6px;
            margin-top: 5px;
            flex-wrap: wrap;
        }
        
        @media (max-width: 768px) {
            .stats-row {
                gap: 4px;
            }
        }
        
        .stat-box {
            background: #fff;
            padding: 5px;
            border-radius: 2px;
            border: 1px solid #ddd;
            flex: 1;
            min-width: 140px;
            text-align: center;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 2px;
        }
        
        .stat-value {
            font-size: 18px;
            color: #000;
            font-weight: bold;
        }
        
        .error {
            color: #d32f2f;
            background: #ffebee;
            padding: 3px;
            border-radius: 2px;
            margin-top: 3px;
            border-left: 2px solid #d32f2f;
            font-size: 12px;
        }
        
        .info {
            color: #000;
            background: #f5f5f5;
            padding: 3px;
            border-radius: 2px;
            margin-top: 3px;
            border-left: 2px solid #000;
            font-size: 12px;
        }
        
        .button-group {
            display: flex;
            gap: 3px;
            margin-top: 5px;
        }
        
        .data-controls {
            display: flex;
            gap: 3px;
            margin-top: 3px;
        }
        
        .data-controls button {
            padding: 2px 5px;
            font-size: 16px;
            background: #000;
        }
        
        .data-controls button:last-child {
            background: #000;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 3px;
            padding: 2px 3px;
            background: #f5f5f5;
            border-radius: 2px;
            font-size: 11px;
               
        }
        
        .point-count {
            color: #333;
            font-weight: 600;
            color: #9ACD32;

        }
        
        .plot-status {
            color: #000;
            font-weight: 600;
            color: #9ACD32;
        }
        
        .param-input input:focus {
            border-color: #000;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
            outline: none;
        }
        
        .function-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 3px;
            padding: 2px 3px;
            background: #f5f5f5;
            border-radius: 2px;
            font-size: 11px;
            color: #9ACD32;
        }
        
        .function-valid {
            color: #9ACD32;
            font-weight: 600;
        }
        
        .function-invalid {
            color: #d32f2f;
            font-weight: 600;
        }
        
        .param-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 6px;
            font-size: 16px;
        }
        
        .param-table th {
            background: #f5f5f5;
            padding: 3px;
            border: 1px solid #ddd;
            text-align: center;
            font-weight: 600;
            color: #000;
        }
        
        .param-table td {
            padding: 3px;
            border: 1px solid #ddd;
            text-align: center;
            background: white;
        }
        
        .param-table .param-name {
            font-weight: 600;
            color: #000;
        }
        
        .param-table .sig-star {
            color: #d32f2f;
            font-weight: bold;
        }
        
        .advanced-stats {
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #ddd;
        }
        
        .advanced-stats h3 {
            color: #000;
            margin-bottom: 5px;
            font-size: 15px;
        }
        
        .export-section {
            margin-top: 7px;
            padding: 6px;
            background: #f9f9f9;
            border-radius: 3px;
            border: 1px solid #ddd;
        }
        
        .export-section h3 {
            color: #000;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 3px;
            font-size: 15px;
        }
        
        .export-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 5px;
            font-size: 11px;
            background: white;
        }
        
        .export-table th {
            background: #f5f5f5;
            padding: 3px;
            border: 1px solid #ddd;
            text-align: left;
            font-weight: 600;
            color: #000;
        }
        
        .export-table td {
            padding: 3px;
            border: 1px solid #e0e0e0;
            font-family: 'Courier New', monospace;
        }
        
        .export-table .category {
            background: #f9f9f9;
            font-weight: 600;
            color: #000;
        }
        
        .copy-buttons {
            display: flex;
            gap: 3px;
            margin-top: 5px;
            flex-wrap: wrap;
        }
        
        .copy-button {
            background: #000;
            color: white;
            border: none;
            padding: 2px 5px;
            border-radius: 2px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .copy-button:hover {
            background: #333;
        }
        
        .copy-button.success {
            background: #000;
        }
        
        .copy-notification {
            position: fixed;
            top: 7px;
            right: 7px;
            background: #000;
            color: white;
            padding: 4px 6px;
            border-radius: 2px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: fadeInOut 2s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-10px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }
        
        .compact-section {
            margin-top: 6px;
            padding: 5px;
            background: #fff;
            border-radius: 3px;
            border: 1px solid #e0e0e0;
            flex: 1; /* FIXED: Allow this section to take available space */
            min-height: 0; /* FIXED: Critical for flex container */
            display: flex;
            flex-direction: column;
            font-size: 11px;
        }
        
        .compact-section h3 {
            color: #333;
            font-size: 14px;
            margin-bottom: 3px;
            border-bottom: 2px solid #000;
            padding-bottom: 2px;
        }
        
        .compact-param-container {
            display: flex;
            flex-direction: column;
            gap: 3px;
            flex: 1; /* FIXED: Take available space */
            min-height: 0; /* FIXED: Allow proper flex behavior */
        }
        
        .run-regression-btn {
            background: #000;
            color: white;
            border: none;
            padding: 4px 7px;
            border-radius: 2px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 5px;
            width: 100%;
        }
        
        .run-regression-btn:hover {
            background: #333;
        }
        
        .compact-param-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            margin-bottom: 2px;
        }
        
        @media (max-width: 1024px) {
            .compact-param-grid,
            .param-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .compact-param-grid,
            .param-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 480px) {
            .compact-param-grid,
            .param-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        small {
            color: #666;
            margin-top: 2px;
            font-size: 11px;
        }
        
        /* Make sure plot container takes full height */
        .plot-section {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .plot-section h2 {
            color: #333;
            font-size: 16px;
            margin-bottom: 5px;
            border-bottom: 2px solid #000;
            padding-bottom: 2px;
            flex-shrink: 0; /* FIXED: Keep header fixed */
        }
        
        /* Red color for parameters */
        .param-red {
            color: #d32f2f;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>RegressionTool: Linear and Nonlinear Regression Analysis</h1>
        <p style="color: white;">Based on the common and standard Levenberg–Marquardt algorithm</p>
        <!-- Download buttons added here -->
        <div class="download-buttons">
            <button class="download-btn" onclick="downloadTXT()">Download TXT</button>
            <button class="download-btn" onclick="downloadExcel()">Download Excel</button>
        &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
        <a href="about.html" style="color: white;">About</a>
        <a href="help.html" style="color: white;">Help</a>
        <a href="privacypolicy.html" style="color: white;">Privacy policy</a>
        
        
        </div>
        
        <br>
        <div class="main-grid">
            <!-- 1. Input Data (X and Y) - 20% width -->
            <div class="section">
                <h2>1. Copy and Paste</h2>
                
                <div class="data-input-container">
                    <div class="data-header">
                        <div>X Data</div>
                        <div>Y Data</div>
                    </div>
                    
                    <div class="data-grid" id="dataGrid">
                        <!-- Data cells will be generated here -->
                    </div>
                    
                    <div class="data-controls">
                        <button onclick="addRow()">Add Row</button>
                        <button onclick="clearData()">Clear All</button>
                    </div>
                </div>
                
                <div class="status-bar">
                    <div class="point-count">Data Points: <span id="pointCount">0</span></div>
                    <div class="plot-status" id="plotStatus">No data plotted</div>
                </div>
                <div id="dataError"></div>
            </div>
            
            <!-- 2. Function Definition - 30% width -->
            <div class="section">
                <h2>2. Function Definition</h2>
                <div class="input-group">
                    <label for="funcInput">Function (use x, <span class="param-red">c1</span>, <span class="param-red">c2</span>, ... <span class="param-red">c10</span>):</label>
                    <input type="text" id="funcInput" placeholder="c1*x^2 + c2*x + c3" value="c1*x^2 + c2*x + c3">
                    <small>Example: <span class="param-red">c1</span>*x^2 + <span class="param-red">c2</span>*x + <span class="param-red">c3</span></small>
                </div>
                
                <div class="input-group" style="margin-top: 5px;">
                    <label for="constraints">Constraints:(Optional)</label>
                    <input type="text" id="constraints">
                    <small>Format: <span class="param-red">c1</span>>0, <span class="param-red">c2</span>&lt;10, <span class="param-red">c3</span>&gt;=0, etc.</small>
                </div>
                
                <div class="function-status" id="functionStatus">
                    <div>Function Status:</div>
                    <div class="function-valid" id="functionValidStatus">Ready</div>
                </div>
    
                <br>
                <div class="compact-section">
                    <h2>3. Initial Parameter Values</h2>
                    <p style="color: black;">For complex nonlinear functions, better initial guesses yield better results.</p>
                    <div class="compact-param-container">
                        <div class="compact-param-grid">
                            <div class="param-input">
                                <label><span class="param-red">c1</span>:</label>
                                <input type="text" id="c1" value="1.0">
                            </div>
                            <div class="param-input">
                                <label><span class="param-red">c2</span>:</label>
                                <input type="text" id="c2" value="1.0">
                            </div>
                            <div class="param-input">
                                <label><span class="param-red">c3</span>:</label>
                                <input type="text" id="c3" value="1.0">
                            </div>
                            <div class="param-input">
                                <label><span class="param-red">c4</span>:</label>
                                <input type="text" id="c4" value="1.0">
                            </div>
                            <div class="param-input">
                                <label><span class="param-red">c5</span>:</label>
                                <input type="text" id="c5" value="1.0">
                            </div>
                        </div>
                        
                        <div class="compact-param-grid">
                            <div class="param-input">
                                <label><span class="param-red">c6</span>:</label>
                                <input type="text" id="c6" value="1.0">
                            </div>
                            <div class="param-input">
                                <label><span class="param-red">c7</span>:</label>
                                <input type="text" id="c7" value="1.0">
                            </div>
                            <div class="param-input">
                                <label><span class="param-red">c8</span>:</label>
                                <input type="text" id="c8" value="1.0">
                            </div>
                            <div class="param-input">
                                <label><span class="param-red">c9</span>:</label>
                                <input type="text" id="c9" value="1.0">
                            </div>
                            <div class="param-input">
                                <label><span class="param-red">c10</span>:</label>
                                <input type="text" id="c10" value="1.0">
                            </div>
                        </div>
                        
                        <button class="run-regression-btn" onclick="runRegression()">Run Regression</button>
                        <div id="functionError" style="flex-shrink: 0;"></div>
                    </div>
                </div>
            </div>
            
            <!-- 3. Data with initial function fit - 35% width (reduced from 50%) -->
            <div class="section plot-section">
                <h2>3. Data with Initial Function Fit</h2>
                <div class="plot-container" id="plotDiv"></div>
            </div>
        </div>
        
        <div id="resultsSection" style="display: none;">
            <div class="results">
                <h2>Optimized Parameters</h2>
                <div class="results-grid" id="optimizedParams"></div>
                
                <h2 style="margin-top: 6px;">Goodness of Fit</h2>
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-label">R (Correlation)</div>
                        <div class="stat-value" id="rValue">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">R² (R-squared)</div>
                        <div class="stat-value" id="r2Value">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Adjusted R²</div>
                        <div class="stat-value" id="adjR2Value">-</div>
                    </div>
                </div>
                
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-label">RMSE</div>
                        <div class="stat-value" id="rmseValue">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">MAE</div>
                        <div class="stat-value" id="maeValue">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">AIC</div>
                        <div class="stat-value" id="aicValue">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">F-Statistic</div>
                        <div class="stat-value" id="fStatValue">-</div>
                    </div>
                </div>
                
                <div class="advanced-stats">
                    <h3>Parameter Statistics</h3>
                    <table class="param-table" id="paramStatsTable">
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Value</th>
                                <th>Std Error</th>
                                <th>t-Statistic</th>
                                <th>p-value</th>
                                <th>Significance</th>
                            </tr>
                        </thead>
                        <tbody id="paramStatsBody">
                            <!-- Will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
                
                <div class="export-section">
                    <h2>
                        <span style="color: #000000;">Export Results to Excel</span>
                    </h2>
                    <p style="color: #666; margin-bottom: 5px; font-size: 12px;">
                        Copy the tables below and paste directly into Excel. Each section is formatted for easy Excel import.
                    </p>
                    
                    <div class="copy-buttons">
                        <button class="copy-button" onclick="copyAllResults()">Copy All Results</button>
                        <button class="copy-button" onclick="copyGoodnessOfFit()">Copy Goodness of Fit</button>
                        <button class="copy-button" onclick="copyParameterStats()">Copy Parameter Statistics</button>
                        <button class="copy-button" onclick="copyRegressionEquation()">Copy Regression Equation</button>
                    </div>
                    
                    <div style="margin-top: 6px;">
                        <h4 style="color: #000; margin-bottom: 3px; font-size: 13px;">Goodness of Fit Metrics</h4>
                        <table class="export-table" id="exportGoodnessTable">
                            <thead>
                                <tr>
                                    <th>Metric</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody id="exportGoodnessBody">
                                <!-- Will be populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                    
                    <div style="margin-top: 6px;">
                        <h4 style="color: #000; margin-bottom: 3px; font-size: 13px;">Parameter Statistics</h4>
                        <table class="export-table" id="exportParamTable">
                            <thead>
                                <tr>
                                    <th>Parameter</th>
                                    <th>Value</th>
                                    <th>Std Error</th>
                                    <th>t-Statistic</th>
                                    <th>p-value</th>
                                    <th>Significance</th>
                                </tr>
                            </thead>
                            <tbody id="exportParamBody">
                                <!-- Will be populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                    
                    <div style="margin-top: 6px;">
                        <h4 style="color: #000; margin-bottom: 3px; font-size: 13px;">Regression Summary</h4>
                        <table class="export-table" id="exportSummaryTable">
                            <thead>
                                <tr>
                                    <th>Item</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody id="exportSummaryBody">
                                <!-- Will be populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="copyNotification" class="copy-notification" style="display: none;"></div>

    <script>
        // The entire JavaScript code remains exactly the same as before
        // Only the CSS and HTML structure has been modified
        let xData = [];
        let yData = [];
        let usedParams = [];
        let dataCells = [];
        let plotUpdateTimeout = null;
        let functionUpdateTimeout = null;
        let paramUpdateTimeout = null;
        let lastFunctionHash = '';
        let lastParamsHash = '';
        let lastDataHash = '';
        let currentRegressionResults = null;
        
        // Track the last focused cell for paste operations
        let lastFocusedCell = null;
        
        // Initialize data grid
        function initializeDataGrid() {
            const grid = document.getElementById('dataGrid');
            grid.innerHTML = '';
            
            // Create 2 columns with 20 initial rows
            const xColumn = document.createElement('div');
            xColumn.className = 'data-column';
            
            const yColumn = document.createElement('div');
            yColumn.className = 'data-column';
            
            dataCells = [];
            
            for (let i = 0; i < 20; i++) {
                const xCell = document.createElement('div');
                xCell.className = 'data-cell empty';
                xCell.contentEditable = 'true';
                xCell.dataset.row = i;
                xCell.dataset.col = 'x';
                xCell.addEventListener('input', handleCellInput);
                xCell.addEventListener('keydown', handleCellKeydown);
                xCell.addEventListener('paste', handlePaste);
                xCell.addEventListener('blur', scheduleDataUpdate);
                xCell.addEventListener('focus', () => {
                    lastFocusedCell = xCell; // Track last focused cell
                });
                xColumn.appendChild(xCell);
                
                const yCell = document.createElement('div');
                yCell.className = 'data-cell empty';
                yCell.contentEditable = 'true';
                yCell.dataset.row = i;
                yCell.dataset.col = 'y';
                yCell.addEventListener('input', handleCellInput);
                yCell.addEventListener('keydown', handleCellKeydown);
                yCell.addEventListener('paste', handlePaste);
                yCell.addEventListener('blur', scheduleDataUpdate);
                yCell.addEventListener('focus', () => {
                    lastFocusedCell = yCell; // Track last focused cell
                });
                yColumn.appendChild(yCell);
                
                dataCells.push({x: xCell, y: yCell});
            }
            
            grid.appendChild(xColumn);
            grid.appendChild(yColumn);
            
            // Add event listeners for function input
            document.getElementById('funcInput').addEventListener('input', scheduleFunctionUpdate);
            
            // Add event listeners for parameter inputs
            for (let i = 1; i <= 10; i++) {
                document.getElementById('c' + i).addEventListener('input', scheduleParamUpdate);
            }
            
            // Add global paste handler for when no cell is focused
            document.addEventListener('paste', handleGlobalPaste);
            
            // Add sample data
            setSampleData();
        }
        
        // Global paste handler for when user pastes without a cell focused
        function handleGlobalPaste(event) {
            // If no cell is focused, try to paste into the first cell
            if (!lastFocusedCell) {
                event.preventDefault();
                
                // Try to find the first cell that's not being edited
                const firstXCell = dataCells[0].x;
                const pasteData = event.clipboardData.getData('text');
                
                if (pasteData.trim()) {
                    // Simulate paste into first cell
                    simulatePaste(firstXCell, pasteData);
                }
            }
        }
        
        function simulatePaste(targetCell, pasteData) {
            // Set the target cell as last focused
            lastFocusedCell = targetCell;
            
            // Create a synthetic paste event
            const syntheticEvent = {
                target: targetCell,
                clipboardData: {
                    getData: () => pasteData
                },
                preventDefault: () => {}
            };
            
            // Call the actual paste handler
            handlePaste(syntheticEvent);
        }
        
        function setSampleData() {
            const sampleX = [1, 2, 3, 4, 5];
            const sampleY = [2.1, 4.3, 6.2, 8.1, 10.3];
            
            for (let i = 0; i < sampleX.length; i++) {
                dataCells[i].x.textContent = sampleX[i];
                dataCells[i].y.textContent = sampleY[i];
                dataCells[i].x.classList.remove('empty');
                dataCells[i].y.classList.remove('empty');
            }
            
            // Automatically plot the sample data
            setTimeout(() => {
                parseDataFromGrid();
                updatePlot();
            }, 100);
        }
        
        function handleCellInput(event) {
            const cell = event.target;
            if (cell.textContent.trim() === '') {
                cell.classList.add('empty');
            } else {
                cell.classList.remove('empty');
            }
            
            // Schedule data update
            scheduleDataUpdate();
        }
        
        function scheduleDataUpdate() {
            // Clear any existing timeout
            if (plotUpdateTimeout) {
                clearTimeout(plotUpdateTimeout);
            }
            
            // Schedule update after a short delay (debouncing)
            plotUpdateTimeout = setTimeout(() => {
                parseDataFromGrid();
                updatePlot();
            }, 300);
        }
        
        function scheduleFunctionUpdate() {
            // Clear any existing timeout
            if (functionUpdateTimeout) {
                clearTimeout(functionUpdateTimeout);
            }
            
            // Schedule update after a short delay
            functionUpdateTimeout = setTimeout(() => {
                checkFunctionAndUpdate();
            }, 500);
        }
        
        function scheduleParamUpdate() {
            // Clear any existing timeout
            if (paramUpdateTimeout) {
                clearTimeout(paramUpdateTimeout);
            }
            
            // Schedule update after a short delay
            paramUpdateTimeout = setTimeout(() => {
                updatePlot();
            }, 500);
        }
        
        function handleCellKeydown(event) {
            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = cell.dataset.col;
            
            switch(event.key) {
                case 'Tab':
                    event.preventDefault();
                    const nextCol = col === 'x' ? 'y' : 'x';
                    const nextRow = event.shiftKey ? Math.max(0, row - 1) : row;
                    focusCell(nextRow, nextCol);
                    break;
                    
                case 'Enter':
                    event.preventDefault();
                    focusCell(row + 1, col);
                    break;
                    
                case 'ArrowUp':
                    event.preventDefault();
                    focusCell(Math.max(0, row - 1), col);
                    break;
                    
                case 'ArrowDown':
                    event.preventDefault();
                    focusCell(row + 1, col);
                    break;
                    
                case 'ArrowLeft':
                    event.preventDefault();
                    focusCell(row, 'x');
                    break;
                    
                case 'ArrowRight':
                    event.preventDefault();
                    focusCell(row, 'y');
                    break;
            }
        }
        
        function focusCell(row, col) {
            if (row >= dataCells.length) {
                addRow();
            }
            
            const cell = col === 'x' ? dataCells[row].x : dataCells[row].y;
            cell.focus();
            
            // Select all text
            const range = document.createRange();
            range.selectNodeContents(cell);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            
            // Track last focused cell
            lastFocusedCell = cell;
        }
        
        function handlePaste(event) {
            event.preventDefault();
            const pasteData = event.clipboardData.getData('text');
            
            // Get the target cell - use event.target or lastFocusedCell as fallback
            let targetCell = event.target;
            
            // If event.target is not a data cell (might be the grid container), use lastFocusedCell
            if (!targetCell.classList || !targetCell.classList.contains('data-cell')) {
                targetCell = lastFocusedCell;
            }
            
            // If still no target cell, use first cell
            if (!targetCell && dataCells.length > 0) {
                targetCell = dataCells[0].x;
            }
            
            if (!targetCell) return;
            
            const startRow = parseInt(targetCell.dataset.row);
            const startCol = targetCell.dataset.col;
            
            const rows = pasteData.trim().split('\n');
            let currentRow = startRow;
            
            for (let i = 0; i < rows.length; i++) {
                const columns = rows[i].split('\t');
                
                if (columns.length >= 2) {
                    // Two columns pasted
                    if (currentRow >= dataCells.length) {
                        addRow();
                    }
                    
                    // Clean and validate data
                    const xVal = columns[0].trim();
                    const yVal = columns[1].trim();
                    
                    if (xVal !== '' && yVal !== '') {
                        dataCells[currentRow].x.textContent = xVal;
                        dataCells[currentRow].y.textContent = yVal;
                        dataCells[currentRow].x.classList.remove('empty');
                        dataCells[currentRow].y.classList.remove('empty');
                    }
                    
                } else if (columns.length === 1) {
                    // Single column pasted
                    if (currentRow >= dataCells.length) {
                        addRow();
                    }
                    
                    const value = columns[0].trim();
                    if (value !== '') {
                        if (startCol === 'x') {
                            dataCells[currentRow].x.textContent = value;
                            dataCells[currentRow].x.classList.remove('empty');
                        } else {
                            dataCells[currentRow].y.textContent = value;
                            dataCells[currentRow].y.classList.remove('empty');
                        }
                    }
                }
                
                currentRow++;
            }
            
            // Focus the last edited cell
            setTimeout(() => {
                if (targetCell) {
                    targetCell.focus();
                    // Select all text in the target cell
                    const range = document.createRange();
                    range.selectNodeContents(targetCell);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
                
                // Trigger plot update immediately after paste
                parseDataFromGrid();
                updatePlot();
            }, 10);
        }
        
        function addRow() {
            const lastRow = dataCells.length;
            const grid = document.getElementById('dataGrid');
            
            // Add to X column
            const xCell = document.createElement('div');
            xCell.className = 'data-cell empty';
            xCell.contentEditable = 'true';
            xCell.dataset.row = lastRow;
            xCell.dataset.col = 'x';
            xCell.addEventListener('input', handleCellInput);
            xCell.addEventListener('keydown', handleCellKeydown);
            xCell.addEventListener('paste', handlePaste);
            xCell.addEventListener('blur', scheduleDataUpdate);
            xCell.addEventListener('focus', () => {
                lastFocusedCell = xCell; // Track last focused cell
            });
            grid.children[0].appendChild(xCell);
            
            // Add to Y column
            const yCell = document.createElement('div');
            yCell.className = 'data-cell empty';
            yCell.contentEditable = 'true';
            yCell.dataset.row = lastRow;
            yCell.dataset.col = 'y';
            yCell.addEventListener('input', handleCellInput);
            yCell.addEventListener('keydown', handleCellKeydown);
            yCell.addEventListener('paste', handlePaste);
            yCell.addEventListener('blur', scheduleDataUpdate);
            yCell.addEventListener('focus', () => {
                lastFocusedCell = yCell; // Track last focused cell
            });
            grid.children[1].appendChild(yCell);
            
            dataCells.push({x: xCell, y: yCell});
        }
        
        function clearData() {
            dataCells.forEach(cellPair => {
                cellPair.x.textContent = '';
                cellPair.y.textContent = '';
                cellPair.x.classList.add('empty');
                cellPair.y.classList.add('empty');
            });
            
            // Keep only first 20 rows
            while (dataCells.length > 20) {
                const lastIndex = dataCells.length - 1;
                dataCells[lastIndex].x.remove();
                dataCells[lastIndex].y.remove();
                dataCells.pop();
            }
            
            // Reset to sample data
            setSampleData();
        }
        
        function parseDataFromGrid() {
            xData = [];
            yData = [];
            
            for (let i = 0; i < dataCells.length; i++) {
                const xVal = parseFloat(dataCells[i].x.textContent.trim());
                const yVal = parseFloat(dataCells[i].y.textContent.trim());
                
                if (!isNaN(xVal) && !isNaN(yVal)) {
                    xData.push(xVal);
                    yData.push(yVal);
                }
            }
            
            // Update point count display
            document.getElementById('pointCount').textContent = xData.length;
            
            return xData.length > 0;
        }
        
        function checkFunctionAndUpdate() {
            const funcStr = document.getElementById('funcInput').value;
            const funcHash = funcStr;
            
            // Only update if function changed
            if (funcHash === lastFunctionHash && xData.length > 0) {
                return;
            }
            
            lastFunctionHash = funcHash;
            usedParams = identifyUsedParams(funcStr);
            
            // Update function status
            const statusElement = document.getElementById('functionValidStatus');
            if (usedParams.length === 0) {
                statusElement.textContent = 'No parameters found';
                statusElement.className = 'function-invalid';
            } else {
                try {
                    // Test if function can be evaluated
                    const testParams = Array(10).fill(1);
                    evaluateFunction(0, testParams);
                    statusElement.textContent = `Valid (using c${usedParams.join(', c')})`;
                    statusElement.className = 'function-valid';
                } catch (e) {
                    statusElement.textContent = 'Invalid function';
                    statusElement.className = 'function-invalid';
                }
            }
            
            // Update plot if we have data
            if (xData.length > 0) {
                updatePlot();
            }
        }
        
        function calculatePlotRange(xDataVals, yDataVals, functionYVals) {
            // Combine all Y values to determine range
            const allYVals = [...yDataVals, ...functionYVals];
            
            // Calculate min and max with padding
            const xMin = Math.min(...xDataVals);
            const xMax = Math.max(...xDataVals);
            const yMin = Math.min(...allYVals);
            const yMax = Math.max(...allYVals);
            
            // Add 10% padding to ranges
            const xRange = xMax - xMin;
            const yRange = yMax - yMin;
            const xPadding = xRange * 0.1;
            const yPadding = yRange * 0.1;
            
            return {
                x: [xMin - xPadding, xMax + xPadding],
                y: [yMin - yPadding, yMax + yPadding]
            };
        }
        
        function updatePlot() {
            if (!parseDataFromGrid() || xData.length === 0) {
                // Show empty plot or placeholder
                const layout = {
                    title: 'Data Visualization',
                    xaxis: { title: 'X', range: [0, 10] },
                    yaxis: { title: 'Y', range: [0, 10] },
                    showlegend: true,
                    legend: {
                        x: 0.02,
                        y: 0.98,
                        bgcolor: 'rgba(255, 255, 255, 0.8)',
                        bordercolor: '#ddd',
                        borderwidth: 1,
                        font: { size: 12 }
                    },
                    annotations: [{
                        text: 'No data to display',
                        xref: 'paper',
                        yref: 'paper',
                        x: 0.5,
                        y: 0.5,
                        showarrow: false,
                        font: { size: 16, color: '#999' }
                    }]
                };
                
                Plotly.newPlot('plotDiv', [], layout);
                document.getElementById('plotStatus').textContent = 'No data plotted';
                document.getElementById('plotStatus').style.color = '#999';
                return;
            }
            
            const errorDiv = document.getElementById('dataError');
            errorDiv.innerHTML = '';
            
            if (xData.length !== yData.length) {
                errorDiv.innerHTML = '<div class="error">X and Y data must have the same length.</div>';
                document.getElementById('plotStatus').textContent = 'Error: Data length mismatch';
                document.getElementById('plotStatus').style.color = '#d32f2f';
                return;
            }
            
            // Get current function and parameters
            const funcStr = document.getElementById('funcInput').value;
            usedParams = identifyUsedParams(funcStr);
            
            if (usedParams.length === 0) {
                // Just show data points if no function defined
                const trace = {
                    x: xData,
                    y: yData,
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Data Points',
                    marker: { size: 8, color: '#2196F3' }
                };
                
                const layout = {
                    title: 'Data Visualization',
                    xaxis: { 
                        title: 'X',
                        range: calculatePlotRange(xData, yData, []).x
                    },
                    yaxis: { 
                        title: 'Y',
                        range: calculatePlotRange(xData, yData, []).y
                    },
                    showlegend: true,
                    legend: {
                        x: 0.02,
                        y: 0.98,
                        bgcolor: 'rgba(255, 255, 255, 0.8)',
                        bordercolor: '#ddd',
                        borderwidth: 1,
                        font: { size: 12 }
                    }
                };
                
                Plotly.newPlot('plotDiv', [trace], layout);
                document.getElementById('plotStatus').textContent = `Data plotted (${xData.length} points)`;
                document.getElementById('plotStatus').style.color = '#000';
                return;
            }
            
            // Try to plot with initial parameters
            try {
                const params = getInitialParams();
                const xMin = Math.min(...xData);
                const xMax = Math.max(...xData);
                const xRange = xMax - xMin;
                const step = xRange / (xData.length * 10);
                
                const xContinuous = [];
                const yContinuous = [];
                
                // Generate function values
                for (let x = xMin; x <= xMax; x += step) {
                    xContinuous.push(x);
                    yContinuous.push(evaluateFunction(x, params));
                }
                
                // Ensure we include the exact endpoint
                xContinuous.push(xMax);
                yContinuous.push(evaluateFunction(xMax, params));
                
                // Calculate plot range that includes both data and function
                const plotRange = calculatePlotRange(xData, yData, yContinuous);
                
                const traceData = {
                    x: xData,
                    y: yData,
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Data Points',
                    marker: { size: 8, color: '#2196F3' }
                };
                
                const traceInitial = {
                    x: xContinuous,
                    y: yContinuous,
                    mode: 'lines',
                    type: 'scatter',
                    name: 'Initial Fit',
                    line: { color: '#FF9800', width: 2 }
                };
                
                const layout = {
                    title: 'Data with Initial Function Fit',
                    xaxis: { 
                        title: 'X',
                        range: plotRange.x
                    },
                    yaxis: { 
                        title: 'Y',
                        range: plotRange.y
                    },
                    showlegend: true,
                    legend: {
                        x: 0.02,
                        y: 0.98,
                        bgcolor: 'rgba(255, 255, 255, 0.8)',
                        bordercolor: '#ddd',
                        borderwidth: 1,
                        font: { size: 12 }
                    }
                };
                
                Plotly.newPlot('plotDiv', [traceData, traceInitial], layout);
                document.getElementById('plotStatus').textContent = `Data with initial fit (${xData.length} points)`;
                document.getElementById('plotStatus').style.color = '#000';
                
            } catch (e) {
                // If function evaluation fails, just show data
                const traceData = {
                    x: xData,
                    y: yData,
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Data Points',
                    marker: { size: 8, color: '#2196F3' }
                };
                
                const layout = {
                    title: 'Data Visualization',
                    xaxis: { 
                        title: 'X',
                        range: calculatePlotRange(xData, yData, []).x
                    },
                    yaxis: { 
                        title: 'Y',
                        range: calculatePlotRange(xData, yData, []).y
                    },
                    showlegend: true,
                    legend: {
                        x: 0.02,
                        y: 0.98,
                        bgcolor: 'rgba(255, 255, 255, 0.8)',
                        bordercolor: '#ddd',
                        borderwidth: 1,
                        font: { size: 12 }
                    }
                };
                
                Plotly.newPlot('plotDiv', [traceData], layout);
                document.getElementById('plotStatus').textContent = `Data plotted (${xData.length} points) - Function error`;
                document.getElementById('plotStatus').style.color = '#FF9800';
            }
            
            // Clear any existing results since data changed
            document.getElementById('resultsSection').style.display = 'none';
        }
        
        // Initialize grid on page load
        document.addEventListener('DOMContentLoaded', initializeDataGrid);
        
        // ====================================================
        // IMPROVEMENT #1: BETTER JACOBIAN (Central Difference)
        // ====================================================
        function jacobian(params) {
            const jac = [];
            for (let i = 0; i < xData.length; i++) {
                const row = [];
                for (let j = 0; j < usedParams.length; j++) {
                    const paramIdx = usedParams[j] - 1;
                    const paramValue = params[paramIdx];
                    
                    // Adaptive step size - much more stable
                    const h = Math.max(1e-8, Math.abs(paramValue) * 1e-6);
                    
                    // Central difference (more accurate than forward difference)
                    const paramsPlus = [...params];
                    const paramsMinus = [...params];
                    
                    paramsPlus[paramIdx] = paramValue + h;
                    paramsMinus[paramIdx] = paramValue - h;
                    
                    try {
                        const fPlus = evaluateFunction(xData[i], paramsPlus);
                        const fMinus = evaluateFunction(xData[i], paramsMinus);
                        
                        // Central difference formula
                        const derivative = (fPlus - fMinus) / (2 * h);
                        
                        // Handle edge cases
                        if (!isFinite(derivative)) {
                            // Fallback to forward difference if central fails
                            const f = evaluateFunction(xData[i], params);
                            row.push((fPlus - f) / h);
                        } else {
                            row.push(derivative);
                        }
                    } catch (e) {
                        // If evaluation fails, use a safe default
                        row.push(1.0);
                    }
                }
                jac.push(row);
            }
            return jac;
        }
        
        function identifyUsedParams(funcStr) {
            const params = [];
            for (let i = 1; i <= 10; i++) {
                if (funcStr.includes('c' + i)) {
                    params.push(i);
                }
            }
            return params;
        }
        
        // ====================================================
        // IMPROVEMENT #2: SAFER FUNCTION EVALUATION (Math.js)
        // ====================================================
        function evaluateFunction(x, params) {
            const funcStr = document.getElementById('funcInput').value;
            
            // First try using Math.js (much safer than eval)
            try {
                // Create scope with all variables
                const scope = {
                    x: x,
                    c1: params[0] || 0,
                    c2: params[1] || 0,
                    c3: params[2] || 0,
                    c4: params[3] || 0,
                    c5: params[4] || 0,
                    c6: params[5] || 0,
                    c7: params[6] || 0,
                    c8: params[7] || 0,
                    c9: params[8] || 0,
                    c10: params[9] || 0  // FIXED: Changed from params[10] to params[9]
                };
                
                // Evaluate using Math.js (already included in your <head>!)
                return math.evaluate(funcStr, scope);
            } catch (mathError) {
                // Fallback to original method for compatibility
                try {
                    const converted = convertFunction(funcStr);
                    const c1 = params[0] || 0;
                    const c2 = params[1] || 0;
                    const c3 = params[2] || 0;
                    const c4 = params[3] || 0;
                    const c5 = params[4] || 0;
                    const c6 = params[5] || 0;
                    const c7 = params[6] || 0;
                    const c8 = params[7] || 0;
                    const c9 = params[8] || 0;
                    const c10 = params[9] || 0;
                    
                    return eval(converted);
                } catch (evalError) {
                    throw new Error('Function error: ' + mathError.message);
                }
            }
        }
        
        function convertFunction(funcStr) {
            let converted = funcStr.replace(/\^/g, '**');
            
            const mathFuncs = ['exp', 'log', 'sin', 'cos', 'tan', 'sqrt', 'abs', 'pow'];
            mathFuncs.forEach(func => {
                const regex = new RegExp('\\b' + func + '\\(', 'g');
                converted = converted.replace(regex, 'Math.' + func + '(');
            });
            
            return converted;
        }
        
        function getInitialParams() {
            const params = [];
            for (let i = 1; i <= 10; i++) {
                const val = document.getElementById('c' + i).value.trim();
                params.push(val === '' ? 1.0 : parseFloat(val));
            }
            return params;
        }
        
        function parseConstraints() {
            const constraintStr = document.getElementById('constraints').value.trim();
            if (!constraintStr) return [];
            
            const constraints = [];
            const parts = constraintStr.split(',');
            
            for (let part of parts) {
                part = part.trim();
                if (!part) continue;
                
                let match = part.match(/c(\d+)\s*(>=|<=|>|<)\s*(-?\d+\.?\d*)/);
                if (match) {
                    constraints.push({
                        param: parseInt(match[1]) - 1,
                        operator: match[2],
                        value: parseFloat(match[3])
                    });
                }
            }
            
            return constraints;
        }
        
        function checkConstraints(params, constraints) {
            for (let c of constraints) {
                const val = params[c.param];
                switch (c.operator) {
                    case '>':
                        if (!(val > c.value)) return false;
                        break;
                    case '<':
                        if (!(val < c.value)) return false;
                        break;
                    case '>=':
                        if (!(val >= c.value)) return false;
                        break;
                    case '<=':
                        if (!(val <= c.value)) return false;
                        break;
                }
            }
            return true;
        }
        
        function residuals(params) {
            const res = [];
            for (let i = 0; i < xData.length; i++) {
                try {
                    const predicted = evaluateFunction(xData[i], params);
                    // Check for invalid predictions
                    if (!isFinite(predicted)) {
                        res.push(1e10); // Large penalty for invalid predictions
                    } else {
                        res.push(yData[i] - predicted);
                    }
                } catch (e) {
                    res.push(1e10); // Large penalty for evaluation errors
                }
            }
            return res;
        }
        
        function matrixMultiply(A, B) {
            const result = [];
            for (let i = 0; i < A.length; i++) {
                result[i] = [];
                for (let j = 0; j < B[0].length; j++) {
                    let sum = 0;
                    for (let k = 0; k < A[0].length; k++) {
                        sum += A[i][k] * B[k][j];
                    }
                    result[i][j] = sum;
                }
            }
            return result;
        }
        
        function transpose(A) {
            return A[0].map((_, i) => A.map(row => row[i]));
        }
        
        function invertMatrix(A) {
            const n = A.length;
            const I = Array(n).fill().map((_, i) => Array(n).fill(0).map((_, j) => i === j ? 1 : 0));
            const M = A.map((row, i) => [...row, ...I[i]]);
            
            for (let i = 0; i < n; i++) {
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) {
                        maxRow = k;
                    }
                }
                [M[i], M[maxRow]] = [M[maxRow], M[i]];
                
                if (Math.abs(M[i][i]) < 1e-10) {
                    throw new Error('Matrix is singular');
                }
                
                const pivot = M[i][i];
                for (let j = 0; j < 2 * n; j++) {
                    M[i][j] /= pivot;
                }
                
                for (let k = 0; k < n; k++) {
                    if (k !== i) {
                        const factor = M[k][i];
                        for (let j = 0; j < 2 * n; j++) {
                            M[k][j] -= factor * M[i][j];
                        }
                    }
                }
            }
            
            return M.map(row => row.slice(n));
        }
        
        function calculateCovarianceMatrix(J, residuals, params) {
            // Calculate covariance matrix: Cov = (J'J)^(-1) * sigma^2
            // where sigma^2 = SSE / (n - p)
            const JT = transpose(J);
            const JTJ = matrixMultiply(JT, J);
            
            try {
                const JTJinv = invertMatrix(JTJ);
                
                // Calculate mean squared error (sigma^2)
                const n = residuals.length;
                const p = params.length;
                const sse = residuals.reduce((sum, r) => sum + r * r, 0);
                const mse = sse / (n - p);
                
                // Scale inverse by MSE
                const cov = JTJinv.map(row => row.map(val => val * mse));
                return cov;
            } catch (e) {
                // If matrix inversion fails, return diagonal matrix
                const p = params.length;
                const n = residuals.length;
                const sse = residuals.reduce((sum, r) => sum + r * r, 0);
                const mse = sse / (n - p);
                
                // Return diagonal matrix with variances
                const cov = Array(p).fill().map(() => Array(p).fill(0));
                for (let i = 0; i < p; i++) {
                    cov[i][i] = mse;
                }
                return cov;
            }
        }
        
        function calculateTStatistic(paramValue, stdError) {
            return paramValue / stdError;
        }
        
        function calculatePValue(tStat, df) {
            // Using two-tailed t-test
            // Simplified approximation - in practice use proper t-distribution
            const absT = Math.abs(tStat);
            
            // Very rough approximation for p-value
            if (absT > 12) return 0.00001;
            if (absT > 8) return 0.0001;
            if (absT > 6) return 0.001;
            if (absT > 4) return 0.01;
            if (absT > 2) return 0.05;
            if (absT > 1.5) return 0.1;
            return 0.2;
        }
        
        function levenbergMarquardt(initialParams, constraints, maxIter = 100, tolerance = 1e-6) {
            // FIXED: Filter parameters correctly based on usedParams
            // usedParams contains indices like [1, 2, 3], so we need to subtract 1
            let params = initialParams.filter((_, i) => usedParams.includes(i + 1));
            let lambda = 0.01;
            let iteration = 0;
            let finalJ = null;
            let finalResiduals = null;
            
            while (iteration < maxIter) {
                const res = residuals(initialParams);
                const J = jacobian(initialParams);
                const JT = transpose(J);
                const JTJ = matrixMultiply(JT, J);
                
                const n = JTJ.length;
                for (let i = 0; i < n; i++) {
                    JTJ[i][i] *= (1 + lambda);
                }
                
                const JTr = matrixMultiply(JT, res.map(r => [r]));
                
                let delta;
                try {
                    const JTJinv = invertMatrix(JTJ);
                    delta = matrixMultiply(JTJinv, JTr).map(row => row[0]);
                } catch (e) {
                    lambda *= 10;
                    iteration++;
                    continue;
                }
                
                const newParamsReduced = params.map((p, i) => p + delta[i]);
                const newParams = [...initialParams];
                
                // Map reduced parameters back to full parameter array
                usedParams.forEach((paramIdx, i) => {
                    newParams[paramIdx - 1] = newParamsReduced[i];
                });
                
                if (constraints.length > 0 && !checkConstraints(newParams, constraints)) {
                    lambda *= 10;
                    iteration++;
                    continue;
                }
                
                const newRes = residuals(newParams);
                const oldSSE = res.reduce((sum, r) => sum + r * r, 0);
                const newSSE = newRes.reduce((sum, r) => sum + r * r, 0);
                
                if (newSSE < oldSSE) {
                    initialParams = newParams;
                    params = newParamsReduced;
                    finalJ = J;
                    finalResiduals = res;
                    lambda /= 10;
                    
                    if (Math.max(...delta.map(Math.abs)) < tolerance) {
                        break;
                    }
                } else {
                    lambda *= 10;
                }
                
                iteration++;
            }
            
            // Return both optimized parameters and Jacobian for covariance calculation
            return {
                params: initialParams,
                jacobian: finalJ,
                residuals: finalResiduals
            };
        }
        
        function calculateAllStatistics(optimizedParams, regressionResult) {
            const n = yData.length;
            const p = usedParams.length;
            const predicted = xData.map((x, i) => evaluateFunction(x, optimizedParams));
            
            // Calculate R²
            const yMean = yData.reduce((a, b) => a + b, 0) / n;
            const ssRes = yData.reduce((sum, y, i) => sum + Math.pow(y - predicted[i], 2), 0);
            const ssTot = yData.reduce((sum, y) => sum + Math.pow(y - yMean, 2), 0);
            const r2 = 1 - (ssRes / ssTot);
            const adjR2 = 1 - ((1 - r2) * (n - 1) / (n - p - 1));
            const r = Math.sqrt(Math.abs(r2)) * (r2 >= 0 ? 1 : -1);
            
            // Calculate error metrics
            let sae = 0;  // Sum of absolute errors
            for (let i = 0; i < n; i++) {
                sae += Math.abs(yData[i] - predicted[i]);
            }
            
            const mse = ssRes / n;
            const rmse = Math.sqrt(mse);
            const mae = sae / n;
            
            // Calculate AIC
            const aic = n * Math.log(ssRes / n) + 2 * p;
            
            // Calculate F-statistic
            const ssReg = ssTot - ssRes;
            const msReg = ssReg / p;
            const msRes = ssRes / (n - p - 1);
            const fStat = msReg / msRes;
            
            // Calculate parameter statistics
            const paramStats = [];
            if (regressionResult.jacobian && regressionResult.residuals) {
                const covMatrix = calculateCovarianceMatrix(
                    regressionResult.jacobian, 
                    regressionResult.residuals, 
                    optimizedParams.filter((_, i) => usedParams.includes(i + 1))
                );
                
                const df = n - p - 1;
                
                for (let i = 0; i < usedParams.length; i++) {
                    const paramIdx = usedParams[i] - 1;
                    const paramValue = optimizedParams[paramIdx];
                    const stdError = Math.sqrt(Math.abs(covMatrix[i][i]));
                    const tStat = calculateTStatistic(paramValue, stdError);
                    const pValue = calculatePValue(tStat, df);
                    
                    paramStats.push({
                        name: `c${usedParams[i]}`,
                        value: paramValue,
                        stdError: stdError,
                        tStat: tStat,
                        pValue: pValue
                    });
                }
            }
            
            return {
                r: r,
                r2: r2,
                adjR2: adjR2,
                rmse: rmse,
                mae: mae,
                aic: aic,
                fStat: fStat,
                paramStats: paramStats,
                n: n,
                p: p,
                ssRes: ssRes,
                ssTot: ssTot,
                ssReg: ssReg
            };
        }
        
        function displayParameterStats(paramStats) {
            const tbody = document.getElementById('paramStatsBody');
            tbody.innerHTML = '';
            
            for (const stat of paramStats) {
                const row = document.createElement('tr');
                
                // Determine significance stars
                let sigStars = '';
                if (stat.pValue < 0.001) sigStars = '***';
                else if (stat.pValue < 0.01) sigStars = '**';
                else if (stat.pValue < 0.05) sigStars = '*';
                else if (stat.pValue < 0.1) sigStars = '.';
                
                row.innerHTML = `
                    <td class="param-name"><span class="param-red">${stat.name}</span></td>
                    <td>${stat.value.toExponential(6)}</td>
                    <td>${stat.stdError.toExponential(6)}</td>
                    <td>${stat.tStat.toFixed(4)}</td>
                    <td>${stat.pValue.toFixed(6)}</td>
                    <td class="sig-star">${sigStars}</td>
                `;
                
                tbody.appendChild(row);
            }
        }
        
        function showCopyNotification(message) {
            const notification = document.getElementById('copyNotification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 2000);
        }
        
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showCopyNotification('Copied to clipboard! Ready to paste into Excel.');
            }).catch(err => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showCopyNotification('Copied to clipboard! Ready to paste into Excel.');
            });
        }
        
        function formatForExcel(value) {
            if (typeof value === 'number') {
                // Use scientific notation for very small/large numbers
                if (Math.abs(value) < 0.001 || Math.abs(value) > 10000) {
                    return value.toExponential(6);
                } else {
                    return value.toFixed(6);
                }
            }
            return value;
        }
        
        function generateExportTables(stats, optimizedParams) {
            // Generate Goodness of Fit table
            const goodnessBody = document.getElementById('exportGoodnessBody');
            goodnessBody.innerHTML = '';
            
            const goodnessData = [
                ['R (Correlation)', formatForExcel(stats.r)],
                ['R² (R-squared)', formatForExcel(stats.r2)],
                ['Adjusted R²', formatForExcel(stats.adjR2)],
                ['RMSE', formatForExcel(stats.rmse)],
                ['MAE', formatForExcel(stats.mae)],
                ['AIC', formatForExcel(stats.aic)],
                ['F-Statistic', formatForExcel(stats.fStat)],
                ['Data Points', stats.n],
                ['Parameters', stats.p],
                ['SS Residual', formatForExcel(stats.ssRes)],
                ['SS Total', formatForExcel(stats.ssTot)],
                ['SS Regression', formatForExcel(stats.ssReg)]
            ];
            
            goodnessData.forEach(([metric, value]) => {
                const row = document.createElement('tr');
                row.innerHTML = `<td>${metric}</td><td>${value}</td>`;
                goodnessBody.appendChild(row);
            });
            
            // Generate Parameter Statistics table
            const paramBody = document.getElementById('exportParamBody');
            paramBody.innerHTML = '';
            
            stats.paramStats.forEach(stat => {
                const row = document.createElement('tr');
                let sigStars = '';
                if (stat.pValue < 0.001) sigStars = '***';
                else if (stat.pValue < 0.01) sigStars = '**';
                else if (stat.pValue < 0.05) sigStars = '*';
                else if (stat.pValue < 0.1) sigStars = '.';
                
                row.innerHTML = `
                    <td><span class="param-red">${stat.name}</span></td>
                    <td>${formatForExcel(stat.value)}</td>
                    <td>${formatForExcel(stat.stdError)}</td>
                    <td>${formatForExcel(stat.tStat)}</td>
                    <td>${formatForExcel(stat.pValue)}</td>
                    <td>${sigStars}</td>
                `;
                paramBody.appendChild(row);
            });
            
            // Generate Summary table
            const summaryBody = document.getElementById('exportSummaryBody');
            summaryBody.innerHTML = '';
            
            const funcStr = document.getElementById('funcInput').value;
            const date = new Date().toLocaleString();
            
            // Highlight parameters in the used parameters string
            const usedParamsStr = usedParams.map(p => `<span class="param-red">c${p}</span>`).join(', ');
            
            const summaryData = [
                ['Regression Function', funcStr],
                ['Analysis Date', date],
                ['Data Points', stats.n],
                ['Fitted Parameters', stats.p],
                ['Used Parameters', usedParamsStr],
                ['R² Value', formatForExcel(stats.r2)],
                ['Adjusted R²', formatForExcel(stats.adjR2)],
                ['RMSE', formatForExcel(stats.rmse)]
            ];
            
            summaryData.forEach(([item, value]) => {
                const row = document.createElement('tr');
                row.innerHTML = `<td>${item}</td><td>${value}</td>`;
                summaryBody.appendChild(row);
            });
            
            return {
                goodnessData,
                paramStats: stats.paramStats,
                summaryData
            };
        }
        
        function copyAllResults() {
            if (!currentRegressionResults) return;
            
            const { goodnessData, paramStats, summaryData } = currentRegressionResults;
            
            let output = "NONLINEAR REGRESSION ANALYSIS RESULTS\n";
            output += "=".repeat(50) + "\n\n";
            
            output += "SUMMARY\n";
            output += "=".repeat(50) + "\n";
            summaryData.forEach(([item, value]) => {
                output += `${item}\t${value}\n`;
            });
            
            output += "\n\nGOODNESS OF FIT\n";
            output += "=".repeat(50) + "\n";
            goodnessData.forEach(([metric, value]) => {
                output += `${metric}\t${value}\n`;
            });
            
            output += "\n\nPARAMETER STATISTICS\n";
            output += "=".repeat(50) + "\n";
            output += "Parameter\tValue\tStd Error\tt-Statistic\tp-value\tSignificance\n";
            paramStats.forEach(stat => {
                let sigStars = '';
                if (stat.pValue < 0.001) sigStars = '***';
                else if (stat.pValue < 0.01) sigStars = '**';
                else if (stat.pValue < 0.05) sigStars = '*';
                else if (stat.pValue < 0.1) sigStars = '.';
                
                output += `${stat.name}\t${formatForExcel(stat.value)}\t${formatForExcel(stat.stdError)}\t${formatForExcel(stat.tStat)}\t${formatForExcel(stat.pValue)}\t${sigStars}\n`;
            });
            
            copyToClipboard(output);
        }
        
        function copyGoodnessOfFit() {
            if (!currentRegressionResults) return;
            
            const { goodnessData } = currentRegressionResults;
            
            let output = "GOODNESS OF FIT METRICS\n";
            output += "=".repeat(50) + "\n";
            output += "Metric\tValue\n";
            
            goodnessData.forEach(([metric, value]) => {
                output += `${metric}\t${value}\n`;
            });
            
            copyToClipboard(output);
        }
        
        function copyParameterStats() {
            if (!currentRegressionResults) return;
            
            const { paramStats } = currentRegressionResults;
            
            let output = "PARAMETER STATISTICS\n";
            output += "=".repeat(50) + "\n";
            output += "Parameter\tValue\tStd Error\tt-Statistic\tp-value\tSignificance\n";
            
            paramStats.forEach(stat => {
                let sigStars = '';
                if (stat.pValue < 0.001) sigStars = '***';
                else if (stat.pValue < 0.01) sigStars = '**';
                else if (stat.pValue < 0.05) sigStars = '*';
                else if (stat.pValue < 0.1) sigStars = '.';
                
                output += `${stat.name}\t${formatForExcel(stat.value)}\t${formatForExcel(stat.stdError)}\t${formatForExcel(stat.tStat)}\t${formatForExcel(stat.pValue)}\t${sigStars}\n`;
            });
            
            copyToClipboard(output);
        }
        
        function copyRegressionEquation() {
            const funcStr = document.getElementById('funcInput').value;
            const optimizedParams = currentRegressionResults?.optimizedParams;
            
            if (!optimizedParams) return;
            
            let output = "REGRESSION EQUATION\n";
            output += "=".repeat(50) + "\n\n";
            output += `Function: y = ${funcStr}\n\n`;
            output += "Optimized Parameters:\n";
            
            usedParams.forEach(i => {
                const paramIdx = i - 1;
                output += `c${i} = ${formatForExcel(optimizedParams[paramIdx])}\n`;
            });
            
            copyToClipboard(output);
        }
        
        function runRegression() {
            if (!parseDataFromGrid() || xData.length === 0) {
                document.getElementById('functionError').innerHTML = '<div class="error">Please enter data first.</div>';
                return;
            }
            
            const funcStr = document.getElementById('funcInput').value;
            usedParams = identifyUsedParams(funcStr);
            
            if (usedParams.length === 0) {
                document.getElementById('functionError').innerHTML = '<div class="error">No parameters found in function.</div>';
                return;
            }
            
            const initialParams = getInitialParams();
            const constraints = parseConstraints();
            
            try {
                const regressionResult = levenbergMarquardt(initialParams, constraints);
                const optimizedParams = regressionResult.params;
                
                // Calculate all statistics
                const stats = calculateAllStatistics(optimizedParams, regressionResult);
                
                // Store results for export
                currentRegressionResults = {
                    stats: stats,
                    optimizedParams: optimizedParams,
                    ...generateExportTables(stats, optimizedParams)
                };
                
                const xMin = Math.min(...xData);
                const xMax = Math.max(...xData);
                const xRange = xMax - xMin;
                
                const xStart = xMin;
                const xEnd = xMax;
                const step = xRange / (xData.length * 10);
                
                const xContinuous = [];
                const yInitial = [];
                const yFitted = [];
                
                for (let x = xStart; x <= xEnd; x += step) {
                    xContinuous.push(x);
                    yInitial.push(evaluateFunction(x, initialParams));
                    yFitted.push(evaluateFunction(x, optimizedParams));
                }
                
                xContinuous.push(xMax);
                yInitial.push(evaluateFunction(xMax, initialParams));
                yFitted.push(evaluateFunction(xMax, optimizedParams));
                
                // Calculate plot range that includes data and both fits
                const plotRange = calculatePlotRange(xData, yData, [...yInitial, ...yFitted]);
                
                const traceData = {
                    x: xData,
                    y: yData,
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Data Points',
                    marker: { size: 8, color: '#2196F3' }
                };
                
                const traceInitial = {
                    x: xContinuous,
                    y: yInitial,
                    mode: 'lines',
                    type: 'scatter',
                    name: 'Initial Fit',
                    line: { color: '#FF9800', width: 2, dash: 'dash' }
                };
                
                const traceFitted = {
                    x: xContinuous,
                    y: yFitted,
                    mode: 'lines',
                    type: 'scatter',
                    name: 'Optimized Fit',
                    line: { color: '#4CAF50', width: 3 }
                };
                
                const layout = {
                    title: 'Regression Results (Within Data Range)',
                    xaxis: { 
                        title: 'X',
                        range: plotRange.x
                    },
                    yaxis: { 
                        title: 'Y',
                        range: plotRange.y
                    },
                    showlegend: true,
                    legend: {
                        x: 0.02,
                        y: 0.98,
                        bgcolor: 'rgba(255, 255, 255, 0.8)',
                        bordercolor: '#ddd',
                        borderwidth: 1,
                        font: { size: 12 }
                    }
                };
                
                Plotly.newPlot('plotDiv', [traceData, traceInitial, traceFitted], layout);
                
                // Display optimized parameters with red color
                const resultsHTML = usedParams.map(i => {
                    return `
                        <div class="result-item">
                            <div class="result-label"><span class="param-red">c${i}</span></div>
                            <div class="result-value">${optimizedParams[i-1].toExponential(6)}</div>
                        </div>
                    `;
                }).join('');
                
                document.getElementById('optimizedParams').innerHTML = resultsHTML;
                
                // Display all statistics
                document.getElementById('rValue').textContent = stats.r.toFixed(6);
                document.getElementById('r2Value').textContent = stats.r2.toFixed(6);
                document.getElementById('adjR2Value').textContent = stats.adjR2.toFixed(6);
                document.getElementById('rmseValue').textContent = stats.rmse.toFixed(6);
                document.getElementById('maeValue').textContent = stats.mae.toFixed(6);
                document.getElementById('aicValue').textContent = stats.aic.toFixed(2);
                document.getElementById('fStatValue').textContent = stats.fStat.toFixed(4);
                
                // Display parameter statistics
                if (stats.paramStats.length > 0) {
                    displayParameterStats(stats.paramStats);
                }
                
                document.getElementById('resultsSection').style.display = 'block';
                document.getElementById('functionError').innerHTML = '<div class="info">Regression completed successfully! All statistics calculated.</div>';
                
            } catch (e) {
                document.getElementById('functionError').innerHTML = '<div class="error">Regression failed: ' + e.message + '</div>';
            }
        }
        
        // ====================================================
        // NEW DOWNLOAD FUNCTIONS
        // ====================================================
        
        function downloadTXT() {
            // Get current date and time for filename
            const date = new Date();
            const timestamp = date.toISOString().slice(0, 19).replace(/[:T]/g, '-');
            const filename = `regression_results_${timestamp}.txt`;
            
            // Collect all inputs and outputs
            let content = "NONLINEAR REGRESSION ANALYSIS - COMPLETE RESULTS\n";
            content += "=".repeat(60) + "\n\n";
            
            // Section 1: Input Data
            content += "1. INPUT DATA\n";
            content += "=".repeat(60) + "\n";
            content += "X Data\tY Data\n";
            
            // Get valid data pairs from grid
            const dataPairs = [];
            for (let i = 0; i < dataCells.length; i++) {
                const xVal = dataCells[i].x.textContent.trim();
                const yVal = dataCells[i].y.textContent.trim();
                if (xVal !== '' && yVal !== '') {
                    dataPairs.push([xVal, yVal]);
                }
            }
            
            // Add data pairs to content
            dataPairs.forEach(pair => {
                content += `${pair[0]}\t${pair[1]}\n`;
            });
            
            content += `\nTotal Data Points: ${dataPairs.length}\n\n`;
            
            // Section 2: Function Definition and Parameters
            content += "2. FUNCTION DEFINITION AND INITIAL PARAMETERS\n";
            content += "=".repeat(60) + "\n";
            content += `Function: ${document.getElementById('funcInput').value}\n`;
            content += `Constraints: ${document.getElementById('constraints').value || 'None'}\n\n`;
            
            content += "Initial Parameter Values:\n";
            for (let i = 1; i <= 10; i++) {
                const paramValue = document.getElementById('c' + i).value;
                content += `c${i} = ${paramValue}\n`;
            }
            content += "\n";
            
            // Section 3: Regression Results (if available)
            if (currentRegressionResults) {
                content += "3. REGRESSION RESULTS\n";
                content += "=".repeat(60) + "\n";
                
                // Optimized Parameters
                content += "Optimized Parameters:\n";
                const optimizedParams = currentRegressionResults.optimizedParams;
                usedParams.forEach(i => {
                    const paramIdx = i - 1;
                    content += `c${i} = ${optimizedParams[paramIdx].toExponential(6)}\n`;
                });
                content += "\n";
                
                // Goodness of Fit
                const stats = currentRegressionResults.stats;
                content += "Goodness of Fit:\n";
                content += `R (Correlation): ${stats.r.toFixed(6)}\n`;
                content += `R² (R-squared): ${stats.r2.toFixed(6)}\n`;
                content += `Adjusted R²: ${stats.adjR2.toFixed(6)}\n`;
                content += `RMSE: ${stats.rmse.toFixed(6)}\n`;
                content += `MAE: ${stats.mae.toFixed(6)}\n`;
                content += `AIC: ${stats.aic.toFixed(2)}\n`;
                content += `F-Statistic: ${stats.fStat.toFixed(4)}\n\n`;
                
                // Parameter Statistics
                if (stats.paramStats.length > 0) {
                    content += "Parameter Statistics:\n";
                    content += "Parameter\tValue\tStd Error\tt-Statistic\tp-value\tSignificance\n";
                    
                    stats.paramStats.forEach(stat => {
                        let sigStars = '';
                        if (stat.pValue < 0.001) sigStars = '***';
                        else if (stat.pValue < 0.01) sigStars = '**';
                        else if (stat.pValue < 0.05) sigStars = '*';
                        else if (stat.pValue < 0.1) sigStars = '.';
                        
                        content += `${stat.name}\t${formatForExcel(stat.value)}\t${formatForExcel(stat.stdError)}\t${formatForExcel(stat.tStat)}\t${formatForExcel(stat.pValue)}\t${sigStars}\n`;
                    });
                }
                
                content += "\n";
                content += `Data Points: ${stats.n}\n`;
                content += `Parameters: ${stats.p}\n`;
                content += `SS Residual: ${formatForExcel(stats.ssRes)}\n`;
                content += `SS Total: ${formatForExcel(stats.ssTot)}\n`;
                content += `SS Regression: ${formatForExcel(stats.ssReg)}\n`;
            } else {
                content += "3. REGRESSION RESULTS\n";
                content += "=".repeat(60) + "\n";
                content += "No regression results available. Run regression first.\n";
            }
            
            // Section 4: Metadata
            content += "\n4. ANALYSIS METADATA\n";
            content += "=".repeat(60) + "\n";
            content += `Analysis Date: ${date.toLocaleString()}\n`;
            content += "Tool: Nonlinear Regression Analysis Web App\n";
            
            // Create and trigger download
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Show notification
            showCopyNotification('TXT file downloaded successfully!');
        }
        
        function downloadExcel() {
            // Get current date and time for filename
            const date = new Date();
            const timestamp = date.toISOString().slice(0, 19).replace(/[:T]/g, '-');
            const filename = `regression_results_${timestamp}.csv`;
            
            // Create CSV content
            let csvContent = "";
            
            // Section 1: Input Data
            csvContent += "INPUT DATA\n";
            csvContent += "X Data,Y Data\n";
            
            // Get valid data pairs from grid
            const dataPairs = [];
            for (let i = 0; i < dataCells.length; i++) {
                const xVal = dataCells[i].x.textContent.trim();
                const yVal = dataCells[i].y.textContent.trim();
                if (xVal !== '' && yVal !== '') {
                    dataPairs.push([xVal, yVal]);
                }
            }
            
            // Add data pairs to CSV
            dataPairs.forEach(pair => {
                csvContent += `${pair[0]},${pair[1]}\n`;
            });
            
            csvContent += `\nTotal Data Points,${dataPairs.length}\n\n`;
            
            // Section 2: Function Definition and Parameters
            csvContent += "FUNCTION DEFINITION AND INITIAL PARAMETERS\n";
            csvContent += `Function,${document.getElementById('funcInput').value}\n`;
            csvContent += `Constraints,${document.getElementById('constraints').value || 'None'}\n`;
            csvContent += "\nInitial Parameter Values\n";
            csvContent += "Parameter,Value\n";
            
            for (let i = 1; i <= 10; i++) {
                const paramValue = document.getElementById('c' + i).value;
                csvContent += `c${i},${paramValue}\n`;
            }
            
            csvContent += "\n";
            
            // Section 3: Regression Results (if available)
            if (currentRegressionResults) {
                csvContent += "REGRESSION RESULTS\n";
                
                // Optimized Parameters
                csvContent += "\nOptimized Parameters\n";
                csvContent += "Parameter,Value\n";
                const optimizedParams = currentRegressionResults.optimizedParams;
                usedParams.forEach(i => {
                    const paramIdx = i - 1;
                    csvContent += `c${i},${optimizedParams[paramIdx].toExponential(6)}\n`;
                });
                
                // Goodness of Fit
                const stats = currentRegressionResults.stats;
                csvContent += "\nGoodness of Fit\n";
                csvContent += "Metric,Value\n";
                csvContent += `R (Correlation),${stats.r.toFixed(6)}\n`;
                csvContent += `R² (R-squared),${stats.r2.toFixed(6)}\n`;
                csvContent += `Adjusted R²,${stats.adjR2.toFixed(6)}\n`;
                csvContent += `RMSE,${stats.rmse.toFixed(6)}\n`;
                csvContent += `MAE,${stats.mae.toFixed(6)}\n`;
                csvContent += `AIC,${stats.aic.toFixed(2)}\n`;
                csvContent += `F-Statistic,${stats.fStat.toFixed(4)}\n`;
                
                // Parameter Statistics
                if (stats.paramStats.length > 0) {
                    csvContent += "\nParameter Statistics\n";
                    csvContent += "Parameter,Value,Std Error,t-Statistic,p-value,Significance\n";
                    
                    stats.paramStats.forEach(stat => {
                        let sigStars = '';
                        if (stat.pValue < 0.001) sigStars = '***';
                        else if (stat.pValue < 0.01) sigStars = '**';
                        else if (stat.pValue < 0.05) sigStars = '*';
                        else if (stat.pValue < 0.1) sigStars = '.';
                        
                        csvContent += `${stat.name},${formatForExcel(stat.value)},${formatForExcel(stat.stdError)},${formatForExcel(stat.tStat)},${formatForExcel(stat.pValue)},${sigStars}\n`;
                    });
                }
                
                csvContent += "\nSummary Statistics\n";
                csvContent += "Statistic,Value\n";
                csvContent += `Data Points,${stats.n}\n`;
                csvContent += `Parameters,${stats.p}\n`;
                csvContent += `SS Residual,${formatForExcel(stats.ssRes)}\n`;
                csvContent += `SS Total,${formatForExcel(stats.ssTot)}\n`;
                csvContent += `SS Regression,${formatForExcel(stats.ssReg)}\n`;
            } else {
                csvContent += "REGRESSION RESULTS\n";
                csvContent += "Status,No regression results available. Run regression first.\n";
            }
            
            // Section 4: Metadata
            csvContent += "\nANALYSIS METADATA\n";
            csvContent += "Item,Value\n";
            csvContent += `Analysis Date,${date.toLocaleString()}\n`;
            csvContent += "Tool,Nonlinear Regression Analysis Web App\n";
            
            // Create and trigger download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Show notification
            showCopyNotification('CSV file downloaded successfully!');
        }
    </script>
</body>
</html>































